{"version":3,"sources":["AutoMapper.ts"],"names":["AutoMapperJs","AutoMapperJs.AutoMapper","AutoMapperJs.AutoMapper.constructor","AutoMapperJs.AutoMapper.getInstance","AutoMapperJs.AutoMapper.createMap","AutoMapperJs.AutoMapper.map","AutoMapperJs.AutoMapper.createMapForMember","AutoMapperJs.AutoMapper.createMapForMemberFindMember","AutoMapperJs.AutoMapper.createMapForMemberHandleMappingFunction","AutoMapperJs.AutoMapper.createMapForMemberHandleMappingFunction.ignore","AutoMapperJs.AutoMapper.createMapForMemberHandleMappingFunction.mapFrom","AutoMapperJs.AutoMapper.createMapForSourceMember","AutoMapperJs.AutoMapper.createMapForSourceMember.ignore","AutoMapperJs.AutoMapper.createMapForAllMembers","AutoMapperJs.AutoMapper.createMapConvertToType","AutoMapperJs.AutoMapper.createMapConvertUsing","AutoMapperJs.AutoMapper.mapArray","AutoMapperJs.AutoMapper.mapItem","AutoMapperJs.AutoMapper.mapProperty","AutoMapperJs.AutoMapper.mapProperty.mapFrom","AutoMapperJs.AutoMapper.mapProperty.ignore","AutoMapperJs.AutoMapper.mapSetValue","AutoMapperJs.AutoMapper.getFunctionParameters","AutoMapperJs.AutoMapper.handleCurrying","AutoMapperJs.AutoMapper.handleCurrying.accumulator"],"mappings":"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","file":"AutoMapper.js","sourcesContent":["/// <reference path=\"TypeConverter.ts\" />\r\n/// <reference path=\"../../tools/typings/arcady-automapper.d.ts\" />\r\n\r\nmodule AutoMapperJs {\r\n    'use strict';\r\n\r\n    /**\r\n     * AutoMapper implementation, for both creating maps and performing maps. Comparable usage and functionality to the original\r\n     * .NET AutoMapper library is the pursuit of this implementation.\r\n     */\r\n    export class AutoMapper {\r\n        private static instance = new AutoMapper();\r\n\r\n        private mappings: { [key: string]: IMapping; };\r\n\r\n        /**\r\n         * Creates a new AutoMapper instance. This class is intended to be a Singleton.\r\n         * Do not use the constructor directly from code. Use getInstance() function instead.\r\n         * @constructor\r\n         */\r\n        constructor() {\r\n            if (AutoMapper.instance) {\r\n                throw new Error('Instantiation failed: Use getInstance() function instead of constructor function.');\r\n            }\r\n            AutoMapper.instance = this;\r\n\r\n            this.mappings = {};\r\n        }\r\n\r\n        /**\r\n         * Gets AutoMapper Singleton instance.\r\n         * @returns {Core.AutoMapper}\r\n         */\r\n        public static getInstance(): IAutoMapper {\r\n            // NOTE BL The ugly conversion to any and IAutoMapper is needed since\r\n            //         AutoMapper and IAutoMapper are not 100% compatible because\r\n            //         of currying support; the IAutoMapper interface, however, is\r\n            //         in fact a 100% functional representation of AutoMapper ;) . \r\n            return <AutoMapperJs.IAutoMapper>(<any>AutoMapper.instance);\r\n        }\r\n\r\n        /**\r\n         * Create a mapping profile.\r\n         * @param {string} sourceKey The map source key.\r\n         * @param {string} destinationKey The map destination key.\r\n         * @returns {Core.IAutoMapperCreateMapChainingFunctions}\r\n         */\r\n        public createMap(sourceKey: string, destinationKey: string): IAutoMapperCreateMapChainingFunctions {\r\n            // provide currying support.\r\n            if (arguments.length < this.createMap.length) {\r\n                return this.handleCurrying(this.createMap, arguments, this);\r\n            }\r\n\r\n            var mappingKey = sourceKey + destinationKey;\r\n\r\n            // create a mapping object for the given keys\r\n            var mapping: IMapping = {\r\n                key: mappingKey,\r\n                forAllMemberMappings: new Array<(destinationObject: any, destinationPropertyName: string, value: any) => void>(),\r\n                forMemberMappings: {},\r\n                typeConverterFunction: undefined,\r\n                destinationTypeClass: undefined\r\n            };\r\n            this.mappings[mappingKey] = mapping;\r\n\r\n            // return an object with available 'sub' functions to enable method chaining \r\n            // (e.g. automapper.createMap().forMember().forMember() ...)\r\n            var fluentApiFuncs: IAutoMapperCreateMapChainingFunctions = {\r\n                forMember: (destinationProperty: string, valueOrFunction: any) =>\r\n                    this.createMapForMember(mapping, fluentApiFuncs, destinationProperty, valueOrFunction),\r\n                forSourceMember: (sourceProperty: string, sourceMemberConfigurationFunction: (opts: ISourceMemberConfigurationOptions) => void) =>\r\n                    this.createMapForSourceMember(mapping, fluentApiFuncs, sourceProperty, sourceMemberConfigurationFunction),\r\n                forAllMembers: (func: (destinationObject: any, destinationPropertyName: string, value: any) => void) =>\r\n                    this.createMapForAllMembers(mapping, fluentApiFuncs, func),\r\n                convertToType: (typeClass: new () => any) =>\r\n                    this.createMapConvertToType(mapping, fluentApiFuncs, typeClass),\r\n                convertUsing: (typeConverterClassOrFunction: any) =>\r\n                    this.createMapConvertUsing(mapping, typeConverterClassOrFunction)\r\n            };\r\n            return fluentApiFuncs;\r\n        }\r\n\r\n        /**\r\n         * Execute a mapping from the source object to a new destination object with explicit mapping configuration and supplied mapping options (using createMap).\r\n         * @param sourceKey Source key, for instance the source type name.\r\n         * @param destinationKey Destination key, for instance the destination type name.\r\n         * @param sourceObject The source object to map.\r\n         * @returns {any} Destination object.\r\n         */\r\n        public map(sourceKey: string, destinationKey: string, sourceObject: any): any {\r\n            // provide currying support.\r\n            if (arguments.length < this.map.length) {\r\n                return this.handleCurrying(this.map, arguments, this);\r\n            }\r\n\r\n            var mappingKey = sourceKey + destinationKey;\r\n            var mapping: IMapping = this.mappings[mappingKey];\r\n            if (!mapping) {\r\n                throw new Error(`Could not find map object with a source of ${sourceKey} and a destination of ${destinationKey}`);\r\n            }\r\n\r\n            if (sourceObject instanceof Array) {\r\n                return this.mapArray(mapping, sourceObject);\r\n            }\r\n\r\n            return this.mapItem(mapping, sourceObject);\r\n        }\r\n\r\n        /**\r\n         * Customize configuration for an individual destination member.\r\n         * @param mapping The mapping configuration for the current mapping keys/types.\r\n         * @param toReturnFunctions The functions object to return to enable fluent layout behavior.\r\n         * @param sourceProperty The destination member property name.\r\n         * @param valueOrFunction The value or function to use for this individual member.\r\n         * @returns {Core.IAutoMapperCreateMapChainingFunctions}\r\n         */\r\n        private createMapForMember(mapping: IMapping,\r\n                                   toReturnFunctions: IAutoMapperCreateMapChainingFunctions,\r\n                                   destinationProperty: string,\r\n                                   valueOrFunction: any): IAutoMapperCreateMapChainingFunctions {\r\n            // find existing mapping for member\r\n            var originalSourcePropertyName: string = undefined;\r\n            var memberMapping = this.createMapForMemberFindMember(mapping, destinationProperty);\r\n            if (memberMapping !== null && memberMapping !== undefined) {\r\n                // do not add additional mappings to a member that is already ignored.\r\n                if (memberMapping.ignore) {\r\n                    return toReturnFunctions;\r\n                }\r\n\r\n                // store original source property name (cloned)\r\n                originalSourcePropertyName = `${memberMapping.sourceProperty}`;\r\n            } else {\r\n                // set defaults for member mapping\r\n                memberMapping = {\r\n                    sourceProperty: destinationProperty,\r\n                    destinationProperty: destinationProperty,\r\n                    mappingValuesAndFunctions: new Array<any>(),\r\n                    ignore: false\r\n                };\r\n            }\r\n\r\n            if (typeof valueOrFunction === 'function') {\r\n                this.createMapForMemberHandleMappingFunction(mapping, memberMapping, valueOrFunction);\r\n            } else {\r\n                memberMapping.mappingValuesAndFunctions.push(valueOrFunction);\r\n            }\r\n\r\n            // if this createMapForMember operation changes the source member (e.g. when mapFrom was specified), we delete\r\n            // the existing member mapping from the dictionary. After that, we add the merged member mapping to the dictionary\r\n            // with the new source member as key.\r\n            if (!originalSourcePropertyName) {\r\n                mapping.forMemberMappings[memberMapping.sourceProperty] = memberMapping;\r\n            } else if (originalSourcePropertyName !== memberMapping.sourceProperty) {\r\n                delete mapping.forMemberMappings[originalSourcePropertyName];\r\n                mapping.forMemberMappings[memberMapping.sourceProperty] = memberMapping;\r\n            }\r\n\r\n            return toReturnFunctions;\r\n        }\r\n\r\n        private createMapForMemberFindMember(mapping: IMapping, destinationPropertyName: string): IForMemberMapping {\r\n            for (let property in mapping.forMemberMappings) {\r\n                if (!mapping.forMemberMappings.hasOwnProperty(property)) {\r\n                    continue;\r\n                }\r\n\r\n                var memberMapping = mapping.forMemberMappings[property];\r\n\r\n                if (memberMapping.destinationProperty === destinationPropertyName) {\r\n                    return mapping.forMemberMappings[property];\r\n                }\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        private createMapForMemberHandleMappingFunction(mapping: IMapping, memberMapping: IForMemberMapping, mappingFunction: (opts: IMemberConfigurationOptions) => any): void {\r\n            var addMappingValueOrFunction = true;\r\n\r\n            // Since we are calling the valueOrFunction function to determine whether to ignore or map from another property, we\r\n            // want to prevent the call to be error prone when the end user uses the '(opts)=> opts.sourceObject.sourcePropertyName'\r\n            // syntax. We don't actually have a source object when creating a mapping; therefore, we 'stub' a source object for the\r\n            // function call.\r\n            var sourceObject: any = {};\r\n            sourceObject[memberMapping.sourceProperty] = {};\r\n\r\n            const destinationMemberConfigurationFunctionOptions: IMemberConfigurationOptions = {\r\n                ignore() {\r\n                    // an ignored member effectively has no mapping values / functions. Remove potentially existing values / functions.\r\n                    memberMapping.ignore = true;\r\n                    memberMapping.sourceProperty = memberMapping.destinationProperty; // in case someone really tried mapFrom before.\r\n                    memberMapping.mappingValuesAndFunctions = new Array<any>();\r\n                    addMappingValueOrFunction = false;\r\n                },\r\n                mapFrom(sourcePropertyName: string) {\r\n                    memberMapping.sourceProperty = sourcePropertyName;\r\n                },\r\n                sourceObject: sourceObject,\r\n                sourcePropertyName: memberMapping.sourceProperty,\r\n                destinationPropertyValue: {}\r\n            };\r\n\r\n            try {\r\n                // calling the function will result in calling our stubbed ignore() and mapFrom() functions if used inside the function.\r\n                mappingFunction(destinationMemberConfigurationFunctionOptions);\r\n            } catch (err) {\r\n                // not foreseeable, but no problem at all (possible by design). We have to catch all potential errors from calling\r\n                // the function, since we cannot predict which goals the end user tries do reach with the stubbed sourceObject property.\r\n            }\r\n\r\n            if (addMappingValueOrFunction) {\r\n                memberMapping.mappingValuesAndFunctions.push(mappingFunction);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Customize configuration for an individual source member.\r\n         * @param mapping The mapping configuration for the current mapping keys/types.\r\n         * @param toReturnFunctions The functions object to return to enable fluent layout behavior.\r\n         * @param sourceProperty The source member property name.\r\n         * @param sourceMemberConfigurationFunction The function to use for this individual member.\r\n         * @returns {Core.IAutoMapperCreateMapChainingFunctions}\r\n         */\r\n        private createMapForSourceMember(mapping: IMapping,\r\n                                         toReturnFunctions: IAutoMapperCreateMapChainingFunctions,\r\n                                         sourceProperty: string,\r\n                                         sourceMemberConfigurationFunction: (opts: ISourceMemberConfigurationOptions) => void): IAutoMapperCreateMapChainingFunctions {\r\n            // set defaults\r\n            var ignore = false;\r\n            var destinationProperty = sourceProperty;\r\n\r\n            if (typeof sourceMemberConfigurationFunction !== 'function') {\r\n                throw new Error('Configuration of forSourceMember has to be a function with one options parameter.');\r\n            }\r\n\r\n            var sourceMemberConfigurationFunctionOptions = {\r\n                ignore() {\r\n                    ignore = true;\r\n                    destinationProperty = undefined;\r\n                }\r\n            };\r\n\r\n            sourceMemberConfigurationFunction(sourceMemberConfigurationFunctionOptions);\r\n\r\n            var memberMapping = mapping.forMemberMappings[sourceProperty];\r\n            if (memberMapping) {\r\n                if (ignore) {\r\n                    memberMapping.ignore = true;\r\n                    memberMapping.mappingValuesAndFunctions = new Array<any>();\r\n                } else {\r\n                    memberMapping.mappingValuesAndFunctions.push(sourceMemberConfigurationFunction);\r\n                }\r\n            } else {\r\n                mapping.forMemberMappings[sourceProperty] = {\r\n                    sourceProperty: sourceProperty,\r\n                    destinationProperty: destinationProperty,\r\n                    mappingValuesAndFunctions: [sourceMemberConfigurationFunction],\r\n                    ignore: ignore\r\n                };\r\n            }\r\n\r\n            return toReturnFunctions;\r\n        }\r\n\r\n        /**\r\n         * Customize configuration for all destination members.\r\n         * @param mapping The mapping configuration for the current mapping keys/types.\r\n         * @param toReturnFunctions The functions object to return to enable fluent layout behavior.\r\n         * @param func The function to use for this individual member.\r\n         * @returns {Core.IAutoMapperCreateMapChainingFunctions}\r\n         */\r\n        private createMapForAllMembers(mapping: IMapping,\r\n                                       toReturnFunctions: IAutoMapperCreateMapChainingFunctions,\r\n                                       func: (destinationObject: any,\r\n                                       destinationPropertyName: string, value: any) => void): IAutoMapperCreateMapChainingFunctions {\r\n            mapping.forAllMemberMappings.push(func);\r\n            return toReturnFunctions;\r\n        }\r\n\r\n        /**\r\n         * Specify to which class type AutoMapper should convert. When specified, AutoMapper will create an instance of the given type, instead of returning a new object literal.\r\n         * @param mapping The mapping configuration for the current mapping keys/types.\r\n         * @param toReturnFunctions The functions object to return to enable fluent layout behavior.\r\n         * @param typeClass The destination type class.\r\n         * @returns {Core.IAutoMapperCreateMapChainingFunctions}\r\n         */\r\n        private createMapConvertToType(mapping: IMapping,\r\n                                       toReturnFunctions: IAutoMapperCreateMapChainingFunctions,\r\n                                       typeClass: new () => any): IAutoMapperCreateMapChainingFunctions {\r\n            mapping.destinationTypeClass = typeClass;\r\n            return toReturnFunctions;\r\n        }\r\n\r\n        /**\r\n         * Skip normal member mapping and convert using a custom type converter (instantiated during mapping).\r\n         * @param mapping The mapping configuration for the current mapping keys/types.\r\n         * @param typeConverterClassOrFunction The converter class or function to use when converting.\r\n         */\r\n        private createMapConvertUsing(mapping: IMapping, typeConverterClassOrFunction: any): void {\r\n            var typeConverterFunction: Function;\r\n\r\n            // 1. check if a function with one parameter is provided; if so, assume it to be the convert function.\r\n            // 2. check if an instance of TypeConverter is provided; in that case, there will be a convert function.\r\n            // 3. assume we are dealing with a class definition, instantiate it and store its convert function.\r\n            // [4. okay, really? the dev providing typeConverterClassOrFunction appears to be an idiot - fire him/her :P .]\r\n            try {\r\n                if (this.getFunctionParameters(typeConverterClassOrFunction).length === 1) {\r\n                    typeConverterFunction = typeConverterClassOrFunction;\r\n                } else if (typeConverterClassOrFunction instanceof TypeConverter) {\r\n                    typeConverterFunction = (<TypeConverter>typeConverterClassOrFunction).convert;\r\n                } else {\r\n                    // ReSharper disable InconsistentNaming\r\n                    typeConverterFunction = (<TypeConverter>new typeConverterClassOrFunction()).convert;\r\n                    // ReSharper restore InconsistentNaming\r\n                }\r\n            } catch (e) {\r\n                throw new Error(`The value provided for typeConverterClassOrFunction is invalid. Exception: ${e}`);\r\n            }\r\n\r\n            if (!typeConverterFunction || this.getFunctionParameters(typeConverterFunction).length !== 1) {\r\n                throw new Error('The value provided for typeConverterClassOrFunction is invalid, because it does not provide exactly one (resolutionContext) parameter.');\r\n            }\r\n\r\n            mapping.typeConverterFunction = <(resolutionContext: IResolutionContext) => any>typeConverterFunction;\r\n        }\r\n\r\n        /**\r\n         * Execute a mapping from the source array to a new destination array with explicit mapping configuration and supplied mapping options (using createMap).\r\n         * @param mapping The mapping configuration for the current mapping keys/types.\r\n         * @param sourceArray The source array to map.\r\n         * @returns {Array<any>} Destination array.\r\n         */\r\n        private mapArray(mapping: IMapping, sourceArray: Array<any>): Array<any> {\r\n            // create empty destination array.\r\n            var destinationArray = new Array<any>();\r\n\r\n            for (var index = 0, length = sourceArray.length; index < length; index++) {\r\n                var sourceObject = sourceArray[index];\r\n\r\n                var destinationObject = this.mapItem(mapping, sourceObject, index);\r\n                if (destinationObject) {\r\n                    destinationArray.push(destinationObject);\r\n                }\r\n            }\r\n\r\n            return destinationArray;\r\n        }\r\n\r\n        /**\r\n         * Execute a mapping from the source object to a new destination object with explicit mapping configuration and supplied mapping options (using createMap).\r\n         * @param mapping The mapping configuration for the current mapping keys/types.\r\n         * @param sourceObject The source object to map.\r\n         * @param arrayIndex The array index number, if this is an array being mapped.\r\n         * @returns {any} Destination object.\r\n         */\r\n        private mapItem(mapping: IMapping, sourceObject: any, arrayIndex: number = undefined): any {\r\n            // create empty destination object.\r\n            // ReSharper disable InconsistentNaming\r\n            var destinationObject = mapping.destinationTypeClass\r\n                ? new mapping.destinationTypeClass()\r\n                : {};\r\n            // ReSharper restore InconsistentNaming\r\n\r\n            if (mapping.typeConverterFunction) {\r\n                var resolutionContext: IResolutionContext = {\r\n                    sourceValue: sourceObject,\r\n                    destinationValue: destinationObject\r\n                };\r\n                return mapping.typeConverterFunction(resolutionContext);\r\n            }\r\n\r\n            for (var sourcePropertyName in sourceObject) {\r\n                if (!sourceObject.hasOwnProperty(sourcePropertyName)) {\r\n                    continue;\r\n                }\r\n\r\n                this.mapProperty(mapping, sourceObject, sourcePropertyName, destinationObject);\r\n            }\r\n\r\n            return destinationObject;\r\n        }\r\n\r\n        /**\r\n         * Execute a mapping from the source object property to the destination object property with explicit mapping configuration and supplied mapping options.\r\n         * @param mapping The mapping configuration for the current mapping keys/types.\r\n         * @param sourceObject The source object to map.\r\n         * @param sourcePropertyName The source property to map.\r\n         * @param destinationObject The destination object to map to.\r\n         */\r\n        private mapProperty(mapping: IMapping, sourceObject: any, sourcePropertyName: string, destinationObject: any): void {\r\n            var propertyMapping = mapping.forMemberMappings[sourcePropertyName];\r\n            if (propertyMapping) {\r\n                // a forMember mapping exists\r\n\r\n                // ignore ignored properties\r\n                if (propertyMapping.ignore) {\r\n                    return;\r\n                }\r\n\r\n                var memberConfigurationOptions: IMemberConfigurationOptions = {\r\n                    mapFrom() {//sourceMemberKey: string) {\r\n                        // no action required, just here as a stub to prevent calling a non-existing 'opts.mapFrom()' function.\r\n                    },\r\n                    ignore() {\r\n                        // no action required, just here as a stub to prevent calling a non-existing 'opts.ignore()' function.\r\n                    },\r\n                    sourceObject: sourceObject,\r\n                    sourcePropertyName: sourcePropertyName,\r\n                    destinationPropertyValue: sourceObject[sourcePropertyName]\r\n                };\r\n\r\n                for (var index = 0, length = propertyMapping.mappingValuesAndFunctions.length; index < length; index++) {\r\n                    var mappingValueOrFunction = propertyMapping.mappingValuesAndFunctions[index];\r\n                    var destinationPropertyValue: any;\r\n\r\n                    if (typeof mappingValueOrFunction === 'function') {\r\n                        destinationPropertyValue = mappingValueOrFunction(memberConfigurationOptions);\r\n                        if (typeof destinationPropertyValue === 'undefined') {\r\n                            destinationPropertyValue = memberConfigurationOptions.destinationPropertyValue;\r\n                        }\r\n                    } else {\r\n                        // mappingValueOrFunction is a value\r\n                        destinationPropertyValue = mappingValueOrFunction;\r\n                    }\r\n\r\n                    memberConfigurationOptions.destinationPropertyValue = destinationPropertyValue;\r\n                }\r\n\r\n                this.mapSetValue(mapping, destinationObject, propertyMapping.destinationProperty, memberConfigurationOptions.destinationPropertyValue);\r\n            } else {\r\n                // no forMember mapping exists\r\n                this.mapSetValue(mapping, destinationObject, sourcePropertyName, sourceObject[sourcePropertyName]);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Set the mapped value on the destination object, either direct or via the (optionally) supplied forAllMembers function(s).\r\n         * @param mapping The mapping configuration for the current mapping keys/types.\r\n         * @param propertyMapping The mapping property configuration for the current property.\r\n         * @param destinationObject The destination object to map to.\r\n         * @param destinationPropertyValue The destination value.\r\n         */\r\n        private mapSetValue(mapping: IMapping, destinationObject: any, destinationPropertyName: string, destinationPropertyValue: any): void {\r\n            if (mapping.forAllMemberMappings.length > 0) {\r\n                for (var i = 0; i < mapping.forAllMemberMappings.length; i++) {\r\n                    mapping.forAllMemberMappings[i](destinationObject, destinationPropertyName, destinationPropertyValue);\r\n                }\r\n            } else {\r\n                destinationObject[destinationPropertyName] = destinationPropertyValue;\r\n            }\r\n        }\r\n\r\n        // TODO BL Perhaps move to separate utility class?\r\n        private getFunctionParameters(func: Function): Array<string> {\r\n            const stripComments = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\r\n            const argumentNames = /([^\\s,]+)/g;\r\n\r\n            var functionString = func.toString().replace(stripComments, '');\r\n            var functionParameterNames = functionString.slice(functionString.indexOf('(') + 1, functionString.indexOf(')')).match(argumentNames);\r\n            if (functionParameterNames === null) {\r\n                functionParameterNames = new Array<string>();\r\n            }\r\n            return functionParameterNames;\r\n        }\r\n\r\n        // TODO BL Perhaps move to separate utility class?\r\n        // TODO BL Document (src: http://www.crockford.com/javascript/www_svendtofte_com/code/curried_javascript/index.html)\r\n        private handleCurrying(func: Function, args: IArguments, closure: any): any {\r\n            const argumentsStillToCome = func.length - args.length;\r\n\r\n            // saved accumulator array\r\n            // NOTE BL this does not deep copy array objects, but only copy the array itself; when side effects occur, please report (or refactor).\r\n            var argumentsCopy = Array.prototype.slice.apply(args);\r\n\r\n            function accumulator(moreArgs: IArguments, alreadyProvidedArgs: Array<any>, stillToCome: number) {\r\n                var previousAlreadyProvidedArgs = alreadyProvidedArgs.slice(0); // to reset\r\n                var previousStillToCome = stillToCome; // to reset\r\n\r\n                for (let i = 0; i < moreArgs.length; i++, stillToCome--) {\r\n                    alreadyProvidedArgs[alreadyProvidedArgs.length] = moreArgs[i];\r\n                }\r\n\r\n                if (stillToCome - moreArgs.length <= 0) {\r\n                    var functionCallResult = func.apply(closure, alreadyProvidedArgs);\r\n\r\n                    // reset vars, so curried function can be applied to new params.\r\n                    // ReSharper disable AssignedValueIsNeverUsed\r\n                    alreadyProvidedArgs = previousAlreadyProvidedArgs;\r\n                    stillToCome = previousStillToCome;\r\n                    // ReSharper restore AssignedValueIsNeverUsed\r\n\r\n                    return functionCallResult;\r\n                } else {\r\n                    // ReSharper disable Lambda\r\n                    return function() {\r\n                        // arguments are params, so closure bussiness is avoided.\r\n                        return accumulator(arguments, alreadyProvidedArgs.slice(0), stillToCome);\r\n                    };\r\n                    // ReSharper restore Lambda\r\n                }\r\n            }\r\n\r\n            return accumulator(<IArguments>(<any>[]), argumentsCopy, argumentsStillToCome);\r\n        }\r\n    }\r\n}\r\n\r\n// Add AutoMapper to the application's global scope. Of course, you could still use \r\n// Core.AutoMapper.getInstance() as well.\r\nvar automapper: AutoMapperJs.IAutoMapper = ((app: any) => {\r\n    if (app.automapper) {\r\n        return app.automapper;\r\n    }\r\n    app.automapper = AutoMapperJs.AutoMapper.getInstance();\r\n    return app.automapper;\r\n})(this);"],"sourceRoot":"/source/"}